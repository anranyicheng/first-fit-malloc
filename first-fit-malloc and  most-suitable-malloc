(defparameter *main-memory* ())
(loop for i from 63 downto 0
			do (push i *main-memory*))
(defparameter *job1* 13)
(defparameter *job2* 6)
(defparameter *job3* 10)
(defparameter *job4* 20)
(defparameter *job5* 14)
(defparameter *job6* 6)
(defparameter *job7* 5)
(defparameter *flag* 0)         
(defun first-fit-malloc(job)
  (let ((lst1())
	(lst2 ())
	(lst3 ())
	(count-aotm 0)
	(count-list 0))
    (dolist (lst *main-memory*)
      (when(atom lst)
	(incf count-aotm))               ;计数 原子的个数
      (when (listp lst)
	(incf count-list))               ;计数 列表的个数
      (if (and (< count-aotm job)        ;原子的个数小于要分配的数
	       (= count-list 1))         ;列表的个数为 1 
	  (progn
	    (dotimes (i (+ count-aotm count-list))
	      (push (pop *main-memory*) lst3))        ;      
	    (setf count-aotm 0)             ;原子的个数清零
	    (setf count-list 0))            ;列表的个数清零
	  (if (>= count-aotm job)
	      (return))))    
	(dotimes (i (length *main-memory*))
	  (if (listp (car *main-memory*))           ;判断列表的首元素是否为列表
	      (progn
		(push (pop *main-memory*) lst2)      ;如果是将它放进lst2
		(setf *flag* 0))
	      (progn
		(do ((x 1 (1+ x)))
		    ((> x job))
		  (push (pop *main-memory*) lst1)) 
		(setf lst1 (list(reverse lst1)))
		(setf lst2 (reverse lst2))
		(setf lst2 (append lst2 lst1))
		(setf *main-memory* (append lst2 *main-memory* ))
		(setf lst3 (reverse lst3))
		(setf *main-memory* (append lst3 *main-memory*))
		(setf *flag* 1)
		(format t "~a ~%" *main-memory*)
		(if (= *flag* 1) (return)))))))
(defun free-memory (job)
  (let ((lst1 ())
	(lst2 ()))
    (dolist (lst *main-memory*)
      (if (atom lst)
	  (push (pop *main-memory*) lst1)
	  (if (and (listp lst)
		   (/= (length lst) job))
	      (push (pop *main-memory*) lst1)
	      (return))))
    (push (pop *main-memory*) lst2)
    (setf lst2 (reverse (car lst2)))
    (dolist (lst  lst2)
      (push lst *main-memory*))
    (setf lst1 (reverse lst1))
    (setf *main-memory* (append lst1 *main-memory*)))
  (format t "~a ~%~%"*main-memory*))

(defun p1()
  (first-fit-malloc *job1*)
  (sleep 1)
  (first-fit-malloc *job2*)
  (sleep 1)
  (first-fit-malloc *job3*)
  (sleep 1)
  (free-memory *job2*)
  (sleep 1)
  (first-fit-malloc *job4*)
  (sleep 1)
  (free-memory *job3*)
  (sleep 1)
  (free-memory *job1*)
  (sleep 1)
  (first-fit-malloc *job5*)
  (sleep 1)
  (first-fit-malloc *job6*)
  (sleep 1)
  (first-fit-malloc *job7*)
  (sleep 1)
  (free-memory *job6*))



(defparameter *position-situation* ())    ;使用一个列表来保存整个内存空间的使用情况
(defun fresh-position-situation()
  (setf *position-situation* ()))

(defun p3(job)
 (when (= (length *position-situation*) 1)
    (let ((lst ()))
      (dotimes ( i job)
	(push (pop *main-memory*) lst))
      (setf lst (reverse lst))
      (push lst *main-memory*)
      (setf lst ())
      (format t "~a ~% " *main-memory*))))     ;首次分配

(defun check-main-memory-situation()
  (fresh-position-situation)
  (let 	((temp ()))
    (dotimes (i (length *main-memory*))                  ;判断已经被使用的内存空间情况
      (when (listp (nth i *main-memory*))
	(push i temp)))
    (push (length *main-memory*) temp)
    (setf temp (reverse temp))
    (setf *position-situation* (append *position-situation* temp))))

(defun most-suitable-position(job)
  (check-main-memory-situation)                   ;刷新得到位置的情况
 ; (format t "内存空间使用情况 ：~a ~%" *position-situation*)
  (let ((position-list ())
	(reduce-p-list ())
	(temp ()))
    (dotimes  (i  (length *position-situation* ))
      (if (= i 0 )
	  (push (- (nth i *position-situation*) 0) position-list)
	  (push (- (nth  i *position-situation*)
		   (nth (1- i) *position-situation*) 1)            ;求出相邻分配空间的剩余大小
		position-list)))
    (setf position-list (reverse position-list))
  ; (format t " 相邻的、已分配空间间隔情况 ：~a ~%" position-list)
    (setf reduce-p-list (mapcar #'(lambda (x) (- x job ))  position-list))   ;将要申请的空间大小与剩余的以分配的相邻
    ;空间大小进行匹配，找到最小值（大于零），第一个已分配于首地址，第二个以分配于第一个以分配
    
  ; (format t "申请的空间预分配影响： ~a ~%" reduce-p-list)
    (setf temp (sort (remove-if #'minusp reduce-p-list) #'<))
  ; (format t " 预分配空间位置产生最少碎片(大于 0 ) ：~a ~%" temp)
    (dotimes (k (length reduce-p-list ))
      (when (and (>= (nth k reduce-p-list)0)
	       (<= (nth k reduce-p-list) (car temp)))
	(return k)))))
(defun most-suitable-malloc(job)
  (let ((tag (most-suitable-position job))
	(prev-list ())
	(tag1 0)
	(collect-list ()))
    (dotimes (i (length *main-memory*))
      (when (listp (car *main-memory*))
	(incf tag1))
      (if (and (= tag 0)
	       (= i 0))
	  (progn
	    (dotimes (j job)
	      (push (pop *main-memory*) collect-list))
	    (setf collect-list (list (reverse collect-list)))
	    (setf *main-memory* (append collect-list *main-memory*))
	    (format t "~a~%~%"  *main-memory*)
	    (return )))
      (if (/= tag1 tag)
	  (progn
	    (push (pop *main-memory*) prev-list))
	  (progn
	      (push (pop *main-memory*) prev-list)
	      (setf prev-list (reverse prev-list))
	    (dotimes (l job)
	      (push (pop *main-memory*) collect-list))
	    (setf collect-list (list (reverse collect-list)))
	    (setf *main-memory* (append collect-list *main-memory*))
	    (setf *main-memory* (append prev-list *main-memory*))
	    (format t "~a~%~%"  *main-memory*)
	    (return))))))

(defun p2 ()
  (most-suitable-malloc *job1*)
  (sleep 1)
  (most-suitable-malloc *job2*)
  (sleep 1)
  (most-suitable-malloc *job3*)
  (sleep 1)
  (free-memory *job2*)
  (sleep 1)
  (most-suitable-malloc *job4*)
  (sleep 1)
  (free-memory *job3*)
  (sleep 1)
  (free-memory *job1*)
  (sleep 1)
  (most-suitable-malloc *job5*)
  (sleep 1)
  (most-suitable-malloc *job6*)
  (sleep 1)
  (most-suitable-malloc *job7*)
  (sleep 1)
  (free-memory *job6*))
